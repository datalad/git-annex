#!/bin/sh

TOPDIR=..

set -x

# remember the refs that were uploaded already
git for-each-ref refs/namespaces/mine/ > .git/old-refs

# Unfortunately, git bundle omits prerequisites that are omitted once,
# even if they are used by a later ref.
# For example, where x is a ref that points at A, and y is a ref
# that points at B (which has A as its parent), git bundle x A..y
# will omit inclding the x ref in the bundle at all.
check_prereq () {
	# So, if a sha is one of the other refs that will be included in the
	# bundle, it cannot be treated as a prerequisite.
	if git for-each-ref refs/namespaces/mine/ | grep -Pv "\t$2$" | awk '{print $1}' | grep -q "$1"; then
		echo "$2"
	else
		# And, if one of the other refs that will be included in the bundle
		# is an ancestor of the sha, it cannot be treated as a prerequisite.
		if [ -n "$(for x in $(git for-each-ref refs/namespaces/mine/ | grep -Pv "\t$2$" | awk '{print $1}'); do git log --oneline -n1 $x..$1; done)" ]; then
			echo "$2"
		else
			echo "$1..$2"
		fi
	fi
}

while read foo; do
	case "$foo" in
		capabilities)
			echo fetch
			echo push
			echo
		;;
		list*)
			if [ -e "$TOPDIR/MANIFEST" ]; then
				# Only list the refs in the last bundle
				# listed in the manifest. Each push
				# includes all refs in its bundle.
				f=$(tail -n 1 $TOPDIR/MANIFEST)
				if [ -n "$f" ]; then
					# refs in the bundle may end up prefixed with refs/namespaces/mine/
					# when the intent is for the bundle to include a
					# ref with the name that comes after that.
					git bundle list-heads $TOPDIR/$f | sed 's/refs\/namespaces\/mine\///'
				fi
			fi
			echo
		;;
		fetch*)
			dofetch=1
		;;
		push*)
			set -- $foo
			x="$2"
			# src ref if prefixed with a + in a forced push
			srcref="$(echo "$x" | cut -d : -f 1 | sed 's/^\+//')"
			dstref="$(echo "$x" | cut -d : -f 2)"
			if [ -z "$srcref" ]; then
				git update-ref -d refs/namespaces/mine/"$dstref"
			else
				# Need to create a bundle containing $dstref, but
				# don't want to overwrite that ref in the local
				# repo. Unfortunately, git bundle does not support
				# GIT_NAMESPACE, so it's not possible to do that
				# without making a clone of the whole git repo.
				# Instead, just create a ref under the namespace
				# refs/namespaces/mine/ that will be put in the
				# bundle.
				git update-ref refs/namespaces/mine/"$dstref" "$srcref"
			fi
			dopush=1
		;;
		# docs say a blank line ends communication, but that's not
		# accurate, actually a blank line comes after a series of
		# fetch or push commands, and also according to the docs,
		# another series of commands could follow
		"")
			if [ "$dofetch" ]; then
				if [ -e "$TOPDIR/MANIFEST" ]; then
					for f in $(cat $TOPDIR/MANIFEST); do
						git bundle unbundle "$TOPDIR/$f" >/dev/null 2>&1
					done
				fi
				echo
				dofetch=""
			fi
			if [ "$dopush" ]; then
				if [ -z "$(git for-each-ref refs/namespaces/mine/)" ]; then
					# deleted all refs
					if [ -e "$TOPDIR/MANIFEST" ]; then
						for f in $(cat $TOPDIR/MANIFEST); do
							rm "$TOPDIR/$f"
						done
						rm $TOPDIR/MANIFEST
						touch $TOPDIR/MANIFEST
					fi
				else
					# set REPUSH=1 to do a full push
					# rather than incremental
					if [ "$REPUSH" ]; then
						rm $TOPDIR/MANIFEST
						rm $TOPDIR/*.bundle
						git for-each-ref refs/namespaces/mine/ | awk '{print $3}' | \
							git bundle create --quiet $TOPDIR/new.bundle --stdin
					else
						# incremental bundle
						IFS="
"
						(for l in $(git for-each-ref refs/namespaces/mine/); do
							r=$(echo "$l" | awk '{print $3}')
							newsha=$(echo "$l" | awk '{print $1}')
							oldsha=$(grep -P "\t$r$" .git/old-refs | awk '{print $1}')
							if [ -n "$oldsha" ]; then
								# include changes from $oldsha to $r when there are some
								if [ -n "$(git log --oneline $oldsha..$r)" ]; then
									check_prereq "$oldsha" "$r"
								else
									if [ "$oldsha" = "$newsha" ]; then
										# $r is unchanged from last push, so include
										# the minimum data to make the bundle contain $r
										rparentsha=$(git log -n 2 "$r" --format='%H' | tail -n+2)
										if [ -n "$rparentsha" ]; then
											check_prereq "$rparentsha" "$r"
										else
											# $r has no parent so include it as is
											echo "$r"
										fi
									else
										# $oldsha is not a parent of $r, so 
										# include $r and all its parents
										echo "$r"
									fi
								fi	
							else
								# no old version was pushed so include $r and all its parents
								echo "$r"
							fi
						done) \
							| git bundle create --quiet $TOPDIR/new.bundle --stdin
					fi
					sha1=$(sha1sum $TOPDIR/new.bundle | awk '{print $1}')
					mv $TOPDIR/new.bundle "$TOPDIR/$sha1.bundle"
					echo "$sha1.bundle" >> $TOPDIR/MANIFEST
				fi
				echo 
				dopush=""
			fi
		;;
	esac
done
