[[!comment format=mdwn
 username="joey"
 subject="""comment 4"""
 date="2024-02-10T14:50:03Z"
 content="""
Another way to use git replace, that is simpler, and requires less
repository hacking:

Checkout the commit just before that problem file was added:

	git checkout 32358

Squash merge the content of master into the working tree:

	git merge --squash master

Convert the problem file to an annexed file:

	git rm --cached $file
	git annex add --force-large $file

Commit the result and replace the master branch with the new commit:

	git commit -m 'rewritten history with $file converted to annexed'
	git replace master HEAD

Now you can checkout the master branch, and see the file is annexed there
now:

	git checkout master
	git-annex find $file

And finally, make one more commit, which can be empty, to have something
new to force push to origin:

	git commit --allow-empty -m 'empty commit after rewrite of history'
	git push --force origin master

Now a new clone from origin will get only the rewritten history, and there
is no need to mess with replace refs, and no errors. You will still have
access to the original history in your repo, and can interoperate with
those clones. And origin will still contain the content of the problem file
until you go in and delete it.

Of course, it's also possible, rather than squashing the whole problematic
history into one commit, to regenerate specific commits to use the annexed
file.
"""]]
